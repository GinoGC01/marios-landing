<canvas id="nanoSpace"></canvas>

<script>
(() => {
  const canvas = document.getElementById("nanoSpace") as HTMLCanvasElement;
  if (!canvas) return;

  const ctx = canvas.getContext("2d")!;
  if (!ctx) return;

  let w: number, h: number, cx: number, cy: number;

  function resize() {
    w = canvas.width = window.innerWidth;
    h = canvas.height = window.innerHeight;
    cx = w / 2;
    cy = h / 2;
  }
  window.addEventListener("resize", resize);
  resize();

  const isMobile = window.innerWidth < 768;

  /* =========================
      CONFIGURACIÓN
  ========================= */
  const STAR_COUNT = isMobile ? 120 : 260;
  const NODE_COUNT = isMobile ? 100 : 520;
  const LINK_DISTANCE = isMobile ? 90 : 120;
  const MOUSE_RADIUS = 160;
  
  // Constantes de explosión (Solo Desktop)
  const EXPLOSION_THRESHOLD = 7;
  const EXPLOSION_RADIUS = 30;
  const EXPLOSION_FORCE = 8;
  const EXPLOSION_COOLDOWN = 10;

  /* =========================
      INTERACCIÓN
  ========================= */
  const mouse = { x: -9999, y: -9999 };
  const interaction = { x: 0, y: 0, intensity: 0 };

  if (!isMobile) {
    window.addEventListener("mousemove", e => {
      mouse.x = e.clientX;
      mouse.y = e.clientY;
    });
    window.addEventListener("mouseleave", () => {
      mouse.x = mouse.y = -9999;
    });
  } else {
    window.addEventListener("pointerdown", e => {
      interaction.x = e.clientX;
      interaction.y = e.clientY;
      interaction.intensity = 1;
    }, { passive: true });
  }

  /* =========================
      STARFIELD 3D
  ========================= */
  class Star {
    x = 0; y = 0; z = 0; size = 0; hue = 0;
    constructor() { this.reset(); }
    reset() {
      this.x = (Math.random() - 0.5) * w;
      this.y = (Math.random() - 0.5) * h;
      this.z = Math.random() * w;
      this.size = 0.4 + Math.random() * 0.8;
      this.hue = 200 + Math.random() * 60;
    }
    update() {
      this.z -= 2.0; // Velocidad de las estrellas
      if (this.z <= 0) this.reset();
    }
    draw() {
      const scale = 380 / this.z;
      const x2d = cx + this.x * scale;
      const y2d = cy + this.y * scale;
      const depth = 1 - this.z / w;
      const alpha = Math.min(1, depth * 1.4);
      const r = depth * 1.2;
      
      const g = ctx.createRadialGradient(x2d, y2d, 0, x2d, y2d, r * 4);
      g.addColorStop(0, `hsla(${this.hue},100%,85%,${alpha})`);
      g.addColorStop(1, `hsla(${this.hue},100%,60%,0)`);
      
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(x2d, y2d, r * 4, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  const stars = Array.from({ length: STAR_COUNT }, () => new Star());

  /* =========================
      NODOS (PARTÍCULAS)
  ========================= */
  const nodes = Array.from({ length: NODE_COUNT }, () => ({
    x: Math.random() * w,
    y: Math.random() * h,
    vx: (Math.random() - 0.5) * 0.5,
    vy: (Math.random() - 0.5) * 0.5,
    influence: 0,
    explosionCooldown: 0,
    randomMoveCounter: Math.random() * 100,
    randomAngle: Math.random() * Math.PI * 2
  }));

  function checkAndHandleExplosions() {
    if (isMobile) return;
    const visited = new Array(nodes.length).fill(false);
    
    for (let i = 0; i < nodes.length; i++) {
      if (visited[i] || nodes[i].explosionCooldown > 0) continue;
      const cluster = [i];
      visited[i] = true;
      for (let j = i + 1; j < nodes.length; j++) {
        if (visited[j] || nodes[j].explosionCooldown > 0) continue;
        const dx = nodes[i].x - nodes[j].x;
        const dy = nodes[i].y - nodes[j].y;
        if (Math.sqrt(dx * dx + dy * dy) < EXPLOSION_RADIUS) {
          cluster.push(j);
          visited[j] = true;
        }
      }
      if (cluster.length >= EXPLOSION_THRESHOLD) {
        handleClusterExplosion(cluster);
      }
    }
  }

  function handleClusterExplosion(cluster: number[]) {
    let centerX = 0, centerY = 0;
    cluster.forEach(idx => { centerX += nodes[idx].x; centerY += nodes[idx].y; });
    centerX /= cluster.length; centerY /= cluster.length;
    
    cluster.forEach(idx => {
      const node = nodes[idx];
      const dx = node.x - centerX;
      const dy = node.y - centerY;
      const distance = Math.hypot(dx, dy) || 1;
      node.vx += (dx / distance) * EXPLOSION_FORCE;
      node.vy += (dy / distance) * EXPLOSION_FORCE;
      node.explosionCooldown = EXPLOSION_COOLDOWN;
    });
    createExplosionVisual(centerX, centerY);
  }
  
  function createExplosionVisual(x: number, y: number) {
    for (let i = 0; i < 10; i++) {
      const angle = Math.random() * Math.PI * 2;
      const speed = 1 + Math.random() * 3;
      ctx.fillStyle = `rgba(140, 255, 200, 0.5)`;
      ctx.beginPath();
      ctx.arc(x + Math.cos(angle) * 10, y + Math.sin(angle) * 10, 1, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  function drawNodes() {
    if (!isMobile) {
      nodes.forEach(node => {
        if (node.explosionCooldown > 0) node.explosionCooldown--;
      });
      checkAndHandleExplosions();
    }
    
    if (isMobile && interaction.intensity > 0) {
      interaction.intensity -= 0.006;
    }

    for (let i = 0; i < nodes.length; i++) {
      const n = nodes[i];
      
      // MOVIMIENTO ALEATORIO (Ahora en ambos, Desktop y Mobile)
      n.randomMoveCounter--;
      if (n.randomMoveCounter <= 0) {
        n.randomAngle = Math.random() * Math.PI * 2;
        n.randomMoveCounter = 40 + Math.random() * 100;
      }
      // Fuerza constante para contrarrestar fricción
      n.vx += Math.cos(n.randomAngle) * 0.009;
      n.vy += Math.sin(n.randomAngle) * 0.009;
      
      n.x += n.vx;
      n.y += n.vy;

      // INTERACCIÓN MOUSE / TOUCH
      if (!isMobile) {
        const dx = mouse.x - n.x;
        const dy = mouse.y - n.y;
        const d = Math.hypot(dx, dy);
        let target = 0;
        if (d < MOUSE_RADIUS) {
          const f = 1 - d / MOUSE_RADIUS;
          n.x += dx * f * 0.02; // Atracción suave
          n.y += dy * f * 0.02;
          target = 1;
        }
        n.influence += (target - n.influence) * 0.1;
      } else if (interaction.intensity > 0) {
        const dx = interaction.x - n.x;
        const dy = interaction.y - n.y;
        const d = Math.hypot(dx, dy);
        const r = 240;
        if (d < r) {
          const s = (1 - d / r) * interaction.intensity;
          n.x += (-dy / (d + 1)) * s * 4;
          n.y += (dx / (d + 1)) * s * 4;
        }
      }

      // Fricción constante
      n.vx *= 0.985;
      n.vy *= 0.985;

      // LÍMITES: TELETRANSPORTE (Wrap-around)
      if (n.x < 0) n.x = w;
      if (n.x > w) n.x = 0;
      if (n.y < 0) n.y = h;
      if (n.y > h) n.y = 0;

      const alpha = isMobile
        ? 0.2 + interaction.intensity * 0.6
        : 0.12 + n.influence * 0.8;

      const isCooling = !isMobile && n.explosionCooldown > 0;
      const color = isCooling 
        ? `rgba(255, 200, 100, ${alpha})`
        : `rgba(180, 140, 255, ${alpha})`;

      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(n.x, n.y, isCooling ? 1.6 : 1.1, 0, Math.PI * 2);
      ctx.fill();

      // DIBUJAR VÍNCULOS
      for (let j = i + 1; j < nodes.length; j++) {
        const m = nodes[j];
        const dx = n.x - m.x;
        const dy = n.y - m.y;
        const d = dx * dx + dy * dy; // Distancia al cuadrado para performance
        const minDist = LINK_DISTANCE * LINK_DISTANCE;

        if (d < minDist) {
          const distFact = 1 - Math.sqrt(d) / LINK_DISTANCE;
          const linkInCooling = !isMobile && (n.explosionCooldown > 0 || m.explosionCooldown > 0);
          
          ctx.strokeStyle = linkInCooling
            ? `rgba(255, 200, 100, ${distFact * alpha * 0.6})`
            : `rgba(140, 255, 200, ${distFact * alpha * 0.8})`;
          
          ctx.lineWidth = linkInCooling ? 0.8 : 0.4;
          ctx.beginPath();
          ctx.moveTo(n.x, n.y);
          ctx.lineTo(m.x, m.y);
          ctx.stroke();
        }
      }
    }
  }

  function animate() {
    // Fondo con rastro mínimo
    ctx.fillStyle = "#020205";
    ctx.fillRect(0, 0, w, h);
    
    stars.forEach(s => { s.update(); s.draw(); });
    drawNodes();
    requestAnimationFrame(animate);
  }

  animate();
})();
</script>

<style>
#nanoSpace {
  position: fixed;
  inset: 0;
  z-index: -1;
  background: radial-gradient(circle at center, #050510 0%, #000 70%);
  touch-action: none;
}
</style>