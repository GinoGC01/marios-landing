<canvas id="nanoSpace"></canvas>

<script>
(() => {
  const canvas = document.getElementById("nanoSpace") as HTMLCanvasElement;
  if (!canvas) return;

  const ctx = canvas.getContext("2d")!;
  if (!ctx) return;

  let w: number, h: number, cx: number, cy: number;

  function resize() {
    w = canvas.width = window.innerWidth;
    h = canvas.height = window.innerHeight;
    cx = w / 2;
    cy = h / 2;
  }
  window.addEventListener("resize", resize);
  resize();

  const isMobile = window.innerWidth < 768;

  /* =========================
     CONFIG
  ========================= */
  const STAR_COUNT = isMobile ? 120 : 260;
  const NODE_COUNT = isMobile ? 100 : 520;
  const LINK_DISTANCE = isMobile ? 90 : 120;
  const MOUSE_RADIUS = 140;
  
  // Nuevas constantes para la explosión
  const EXPLOSION_THRESHOLD = 7;
  const EXPLOSION_RADIUS = 30;
  const EXPLOSION_FORCE = 8;
  const EXPLOSION_COOLDOWN = 10; // frames

  /* =========================
     INTERACCIÓN
  ========================= */
  const mouse = { x: -9999, y: -9999 };
  const interaction = { x: 0, y: 0, intensity: 0 };

  if (!isMobile) {
    window.addEventListener("mousemove", e => {
      mouse.x = e.clientX;
      mouse.y = e.clientY;
    });
    window.addEventListener("mouseleave", () => {
      mouse.x = mouse.y = -9999;
    });
  } else {
    window.addEventListener("pointerdown", e => {
      interaction.x = e.clientX;
      interaction.y = e.clientY;
      interaction.intensity = 1;
    }, { passive: true });
  }

  /* =========================
     STARFIELD 3D
  ========================= */
  class Star {
    x = 0;
    y = 0;
    z = 0;
    size = 0;
    hue = 0;
    
    constructor() {
      this.reset();
    }

    reset() {
      this.x = (Math.random() - 0.5) * w;
      this.y = (Math.random() - 0.5) * h;
      this.z = Math.random() * w;
      this.size = 0.4 + Math.random() * 0.8;
      this.hue = 200 + Math.random() * 60;
    }
    
    update() {
      this.z -= 2.4;
      if (this.z <= 0) this.reset();
    }
    
    draw() {
      const scale = 380 / this.z;
      const x2d = cx + this.x * scale;
      const y2d = cy + this.y * scale;
      const depth = 1 - this.z / w;
      const alpha = Math.min(1, depth * 1.4);
      const r = depth * 1;

      const g = ctx.createRadialGradient(
        x2d, y2d, 0,
        x2d, y2d, r * 4
      );
      g.addColorStop(0, `hsla(${this.hue},100%,85%,${alpha})`);
      g.addColorStop(1, `hsla(${this.hue},100%,60%,0)`);

      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(x2d, y2d, r * 4, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = `hsla(${this.hue},100%,90%,${alpha})`;
      ctx.beginPath();
      ctx.arc(x2d, y2d, r * 1.2, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  const stars = Array.from({ length: STAR_COUNT }, () => new Star());

  /* =========================
     NODOS
  ========================= */
  const nodes = Array.from({ length: NODE_COUNT }, () => ({
    x: Math.random() * w,
    y: Math.random() * h,
    vx: (Math.random() - 0.5) * 0.35,
    vy: (Math.random() - 0.5) * 0.35,
    influence: 0,
    // Nueva propiedad para el cooldown de explosión
    explosionCooldown: 0,
    // Contador para movimiento aleatorio en móvil
    randomMoveCounter: Math.random() * 100,
    // Dirección aleatoria inicial para móvil
    randomAngle: Math.random() * Math.PI * 2
  }));

  // Función para verificar y manejar explosiones
  function checkAndHandleExplosions() {
    const clusters: number[][] = [];
    const visited = new Array(nodes.length).fill(false);
    
    // Detectar clusters de nodos cercanos
    for (let i = 0; i < nodes.length; i++) {
      if (visited[i] || nodes[i].explosionCooldown > 0) continue;
      
      const cluster = [i];
      visited[i] = true;
      
      // Búsqueda de nodos cercanos
      for (let j = i + 1; j < nodes.length; j++) {
        if (visited[j] || nodes[j].explosionCooldown > 0) continue;
        
        const dx = nodes[i].x - nodes[j].x;
        const dy = nodes[i].y - nodes[j].y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance < EXPLOSION_RADIUS) {
          cluster.push(j);
          visited[j] = true;
        }
      }
      
      // Si el cluster tiene suficientes nodos, añadirlo a la lista
      if (cluster.length >= EXPLOSION_THRESHOLD) {
        clusters.push(cluster);
      }
    }
    
    // Manejar explosiones para cada cluster encontrado
    clusters.forEach(cluster => {
      // Calcular centro del cluster
      let centerX = 0;
      let centerY = 0;
      
      cluster.forEach(idx => {
        centerX += nodes[idx].x;
        centerY += nodes[idx].y;
      });
      
      centerX /= cluster.length;
      centerY /= cluster.length;
      
      // Aplicar fuerza explosiva a cada nodo en el cluster
      cluster.forEach(idx => {
        const node = nodes[idx];
        
        // Calcular dirección desde el centro
        const dx = node.x - centerX;
        const dy = node.y - centerY;
        const distance = Math.sqrt(dx * dx + dy * dy) || 1;
        
        // Normalizar dirección y aplicar fuerza
        const forceX = (dx / distance) * EXPLOSION_FORCE;
        const forceY = (dy / distance) * EXPLOSION_FORCE;
        
        node.vx += forceX;
        node.vy += forceY;
        
        // Aplicar cooldown
        node.explosionCooldown = EXPLOSION_COOLDOWN;
        
        // Efecto visual adicional (partículas brillantes en el centro)
        createExplosionEffect(centerX, centerY);
      });
    });
  }
  
  // Función para crear efecto visual de explosión
  function createExplosionEffect(x, y) {
    // Crear partículas de efecto de explosión
    for (let i = 0; i < 15; i++) {
      const angle = Math.random() * Math.PI * 2;
      const speed = 2 + Math.random() * 4;
      const size = 1 + Math.random() * 2;
      
      // Dibujar partícula de explosión
      ctx.fillStyle = `rgba(255, 200, 100, 0.8)`;
      ctx.beginPath();
      ctx.arc(
        x + Math.cos(angle) * speed * 3,
        y + Math.sin(angle) * speed * 3,
        size,
        0,
        Math.PI * 2
      );
      ctx.fill();
    }
  }

  function drawNodes() {
    // Reducir cooldown de explosión
    nodes.forEach(node => {
      if (node.explosionCooldown > 0) {
        node.explosionCooldown--;
      }
    });
    
    // Verificar explosiones antes de actualizar posiciones
    checkAndHandleExplosions();
    
    if (isMobile && interaction.intensity > 0) {
      interaction.intensity -= 0.006;
    }

    for (let i = 0; i < nodes.length; i++) {
      const n = nodes[i];
      
      // MOVIMIENTO ALEATORIO SOLO EN MÓVIL
      if (isMobile) {
        n.randomMoveCounter--;
        if (n.randomMoveCounter <= 0) {
          // Cambiar dirección aleatoriamente
          n.randomAngle = Math.random() * Math.PI * 2;
          // Tiempo hasta el próximo cambio (entre 30 y 90 frames)
          n.randomMoveCounter = 30 + Math.random() * 60;
        }
        
        // Aplicar movimiento aleatorio suave
        const randomSpeed = 0.15;
        n.vx += Math.cos(n.randomAngle) * randomSpeed * 0.05;
        n.vy += Math.sin(n.randomAngle) * randomSpeed * 0.05;
        
        // Pequeñas fluctuaciones aleatorias adicionales
        if (Math.random() < 0.1) {
          n.vx += (Math.random() - 0.5) * 0.08;
          n.vy += (Math.random() - 0.5) * 0.08;
        }
      }
      
      n.x += n.vx;
      n.y += n.vy;

      // Desktop: mouse
      if (!isMobile) {
        const dx = mouse.x - n.x;
        const dy = mouse.y - n.y;
        const d = Math.hypot(dx, dy);
        let target = 0;

        if (d < MOUSE_RADIUS) {
          const f = 1 - d / MOUSE_RADIUS;
          n.x += dx * f * 0.015;
          n.y += dy * f * 0.015;
          target = 1;
        }
        n.influence += (target - n.influence) * 0.12;
      }

      // Mobile: vórtice
      if (isMobile && interaction.intensity > 0) {
        const dx = interaction.x - n.x;
        const dy = interaction.y - n.y;
        const d = Math.hypot(dx, dy);
        const r = 240;

        if (d < r) {
          const s = (1 - d / r) * interaction.intensity;
          const tx = -dy / (d + 1);
          const ty = dx / (d + 1);
          n.x += tx * s * 4;
          n.y += ty * s * 4;
        }
      }

      // Reducir velocidad gradualmente (amortiguación)
      n.vx *= 0.99;
      n.vy *= 0.99;

      // Mantener dentro de límites
      if (n.x < 0) {
        n.x = w;
        n.vx *= -0.5;
      }
      if (n.x > w) {
        n.x = 0;
        n.vx *= -0.5;
      }
      if (n.y < 0) {
        n.y = h;
        n.vy *= -0.5;
      }
      if (n.y > h) {
        n.y = 0;
        n.vy *= -0.5;
      }

      const alpha = isMobile
        ? 0.25 + interaction.intensity * 0.6
        : 0.15 + n.influence * 0.85;

      // Cambiar color si está en cooldown de explosión
      const isCooling = n.explosionCooldown > 0;
      const color = isCooling 
        ? `rgba(255, ${200 - n.explosionCooldown * 2}, 100, ${alpha})`
        : `rgba(180, 140, 255, ${alpha})`;

      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(n.x, n.y, isCooling ? 1.8 : 1.3, 0, Math.PI * 2);
      ctx.fill();

      for (let j = i + 1; j < nodes.length; j++) {
        const m = nodes[j];
        const d = Math.hypot(n.x - m.x, n.y - m.y);
        if (d < LINK_DISTANCE) {
          // Cambiar color de línea si alguno está en cooldown
          const lineColor = (n.explosionCooldown > 0 || m.explosionCooldown > 0)
            ? `rgba(255, 200, 100, ${(1 - d / LINK_DISTANCE) * alpha * 0.7})`
            : `rgba(140, 255, 200, ${(1 - d / LINK_DISTANCE) * alpha})`;
          
          ctx.strokeStyle = lineColor;
          ctx.lineWidth = isCooling ? 0.7 : 0.45;
          ctx.beginPath();
          ctx.moveTo(n.x, n.y);
          ctx.lineTo(m.x, m.y);
          ctx.stroke();
        }
      }
    }
  }

  /* =========================
     LOOP
  ========================= */
  function animate() {
    ctx.fillStyle = "#020205";
    ctx.fillRect(0, 0, w, h);

    stars.forEach(s => { s.update(); s.draw(); });
    drawNodes();

    requestAnimationFrame(animate);
  }

  animate();
})();
</script>

<style>
#nanoSpace {
  position: fixed;
  inset: 0;
  z-index: -1;
  background: radial-gradient(circle at center, #050510 0%, #000 70%);
  touch-action: none;
}
</style>