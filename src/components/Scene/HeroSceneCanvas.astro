<canvas id="nanoSpace"></canvas>

<script>
(() => {
  const canvas = document.getElementById("nanoSpace") as HTMLCanvasElement;
  if (!canvas) return;

  const ctx = canvas.getContext("2d")!;
  if (!ctx) return;

  let w: number, h: number, cx: number, cy: number;

  function resize() {
    w = canvas.width = window.innerWidth;
    h = canvas.height = window.innerHeight;
    cx = w / 2;
    cy = h / 2;
  }
  window.addEventListener("resize", resize);
  resize();

  const isMobile = window.innerWidth < 768;

  /* =========================
      CONFIG
  ========================= */
  const STAR_COUNT = isMobile ? 120 : 260;
  const NODE_COUNT = isMobile ? 100 : 520;
  const LINK_DISTANCE = isMobile ? 90 : 120;
  const MOUSE_RADIUS = 140;
  
  // Estas constantes solo tendrán efecto real en Desktop
  const EXPLOSION_THRESHOLD = 7;
  const EXPLOSION_RADIUS = 30;
  const EXPLOSION_FORCE = 8;
  const EXPLOSION_COOLDOWN = 10;

  /* =========================
      INTERACCIÓN
  ========================= */
  const mouse = { x: -9999, y: -9999 };
  const interaction = { x: 0, y: 0, intensity: 0 };

  if (!isMobile) {
    window.addEventListener("mousemove", e => {
      mouse.x = e.clientX;
      mouse.y = e.clientY;
    });
    window.addEventListener("mouseleave", () => {
      mouse.x = mouse.y = -9999;
    });
  } else {
    window.addEventListener("pointerdown", e => {
      interaction.x = e.clientX;
      interaction.y = e.clientY;
      interaction.intensity = 1;
    }, { passive: true });
  }

  /* =========================
      STARFIELD 3D
  ========================= */
  class Star {
    x = 0; y = 0; z = 0; size = 0; hue = 0;
    constructor() { this.reset(); }
    reset() {
      this.x = (Math.random() - 0.5) * w;
      this.y = (Math.random() - 0.5) * h;
      this.z = Math.random() * w;
      this.size = 0.4 + Math.random() * 0.8;
      this.hue = 200 + Math.random() * 60;
    }
    update() {
      this.z -= 2.4;
      if (this.z <= 0) this.reset();
    }
    draw() {
      const scale = 380 / this.z;
      const x2d = cx + this.x * scale;
      const y2d = cy + this.y * scale;
      const depth = 1 - this.z / w;
      const alpha = Math.min(1, depth * 1.4);
      const r = depth * 1;
      const g = ctx.createRadialGradient(x2d, y2d, 0, x2d, y2d, r * 4);
      g.addColorStop(0, `hsla(${this.hue},100%,85%,${alpha})`);
      g.addColorStop(1, `hsla(${this.hue},100%,60%,0)`);
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(x2d, y2d, r * 4, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  const stars = Array.from({ length: STAR_COUNT }, () => new Star());

  /* =========================
      NODOS
  ========================= */
  const nodes = Array.from({ length: NODE_COUNT }, () => ({
    x: Math.random() * w,
    y: Math.random() * h,
    vx: (Math.random() - 0.5) * 0.35,
    vy: (Math.random() - 0.5) * 0.35,
    influence: 0,
    explosionCooldown: 0,
    randomMoveCounter: Math.random() * 100,
    randomAngle: Math.random() * Math.PI * 2
  }));

  function checkAndHandleExplosions() {
    if (isMobile) return; // Salvaguarda adicional
    const clusters: number[][] = [];
    const visited = new Array(nodes.length).fill(false);
    
    for (let i = 0; i < nodes.length; i++) {
      if (visited[i] || nodes[i].explosionCooldown > 0) continue;
      const cluster = [i];
      visited[i] = true;
      for (let j = i + 1; j < nodes.length; j++) {
        if (visited[j] || nodes[j].explosionCooldown > 0) continue;
        const dx = nodes[i].x - nodes[j].x;
        const dy = nodes[i].y - nodes[j].y;
        if (Math.sqrt(dx * dx + dy * dy) < EXPLOSION_RADIUS) {
          cluster.push(j);
          visited[j] = true;
        }
      }
      if (cluster.length >= EXPLOSION_THRESHOLD) clusters.push(cluster);
    }
    
    clusters.forEach(cluster => {
      let centerX = 0, centerY = 0;
      cluster.forEach(idx => { centerX += nodes[idx].x; centerY += nodes[idx].y; });
      centerX /= cluster.length; centerY /= cluster.length;
      
      cluster.forEach(idx => {
        const node = nodes[idx];
        const dx = node.x - centerX;
        const dy = node.y - centerY;
        const distance = Math.sqrt(dx * dx + dy * dy) || 1;
        node.vx += (dx / distance) * EXPLOSION_FORCE;
        node.vy += (dy / distance) * EXPLOSION_FORCE;
        node.explosionCooldown = EXPLOSION_COOLDOWN;
        createExplosionEffect(centerX, centerY);
      });
    });
  }
  
  function createExplosionEffect(x: number, y: number) {
    for (let i = 0; i < 15; i++) {
      const angle = Math.random() * Math.PI * 2;
      const speed = 2 + Math.random() * 4;
      ctx.fillStyle = `rgba(255, 200, 100, 0.8)`;
      ctx.beginPath();
      ctx.arc(x + Math.cos(angle) * speed * 3, y + Math.sin(angle) * speed * 3, 1 + Math.random() * 2, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  function drawNodes() {
    // Solo procesamos lógica de explosión si NO es móvil
    if (!isMobile) {
      nodes.forEach(node => {
        if (node.explosionCooldown > 0) node.explosionCooldown--;
      });
      checkAndHandleExplosions();
    }
    
    if (isMobile && interaction.intensity > 0) {
      interaction.intensity -= 0.006;
    }

    for (let i = 0; i < nodes.length; i++) {
      const n = nodes[i];
      
      if (isMobile) {
        n.randomMoveCounter--;
        if (n.randomMoveCounter <= 0) {
          n.randomAngle = Math.random() * Math.PI * 2;
          n.randomMoveCounter = 30 + Math.random() * 60;
        }
        n.vx += Math.cos(n.randomAngle) * 0.0075;
        n.vy += Math.sin(n.randomAngle) * 0.0075;
      }
      
      n.x += n.vx;
      n.y += n.vy;

      if (!isMobile) {
        const dx = mouse.x - n.x;
        const dy = mouse.y - n.y;
        const d = Math.hypot(dx, dy);
        let target = 0;
        if (d < MOUSE_RADIUS) {
          const f = 1 - d / MOUSE_RADIUS;
          n.x += dx * f * 0.015;
          n.y += dy * f * 0.015;
          target = 1;
        }
        n.influence += (target - n.influence) * 0.12;
      } else if (interaction.intensity > 0) {
        const dx = interaction.x - n.x;
        const dy = interaction.y - n.y;
        const d = Math.hypot(dx, dy);
        const r = 240;
        if (d < r) {
          const s = (1 - d / r) * interaction.intensity;
          n.x += (-dy / (d + 1)) * s * 4;
          n.y += (dx / (d + 1)) * s * 4;
        }
      }

      n.vx *= 0.99;
      n.vy *= 0.99;

      // Límites
      if (n.x < 0) { n.x = w; n.vx *= -0.5; }
      if (n.x > w) { n.x = 0; n.vx *= -0.5; }
      if (n.y < 0) { n.y = h; n.vy *= -0.5; }
      if (n.y > h) { n.y = 0; n.vy *= -0.5; }

      const alpha = isMobile
        ? 0.25 + interaction.intensity * 0.6
        : 0.15 + n.influence * 0.85;

      // isCooling siempre será false en Mobile porque nunca se activa el cooldown
      const isCooling = !isMobile && n.explosionCooldown > 0;
      const color = isCooling 
        ? `rgba(255, ${200 - n.explosionCooldown * 2}, 100, ${alpha})`
        : `rgba(180, 140, 255, ${alpha})`;

      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(n.x, n.y, isCooling ? 1.8 : 1.3, 0, Math.PI * 2);
      ctx.fill();

      for (let j = i + 1; j < nodes.length; j++) {
        const m = nodes[j];
        const d = Math.hypot(n.x - m.x, n.y - m.y);
        if (d < LINK_DISTANCE) {
          const linkInCooling = !isMobile && (n.explosionCooldown > 0 || m.explosionCooldown > 0);
          ctx.strokeStyle = linkInCooling
            ? `rgba(255, 200, 100, ${(1 - d / LINK_DISTANCE) * alpha * 0.7})`
            : `rgba(140, 255, 200, ${(1 - d / LINK_DISTANCE) * alpha})`;
          ctx.lineWidth = linkInCooling ? 0.7 : 0.45;
          ctx.beginPath();
          ctx.moveTo(n.x, n.y);
          ctx.lineTo(m.x, m.y);
          ctx.stroke();
        }
      }
    }
  }

  function animate() {
    ctx.fillStyle = "#020205";
    ctx.fillRect(0, 0, w, h);
    stars.forEach(s => { s.update(); s.draw(); });
    drawNodes();
    requestAnimationFrame(animate);
  }

  animate();
})();
</script>

<style>
#nanoSpace {
  position: fixed;
  inset: 0;
  z-index: -1;
  background: radial-gradient(circle at center, #050510 0%, #000 70%);
  touch-action: none;
}
</style>